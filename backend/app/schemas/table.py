from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any

# Shared properties
class ManagedTableBase(BaseModel):
    table_number: int = Field(..., example=15)
    override_main_qr_link: Optional[str] = Field(default=None, example="https://custom-link.com/table15")
    overridden_links: Optional[Dict[str, Any]] = Field(default=None, example={"instagram": "https://instagram.com/special_table"})
    branch_id: int # Should be set automatically or based on context

# Properties to receive via API on creation (usually not created individually?)
# Use ManagedTableBulkCreate for bulk creation
class ManagedTableCreate(ManagedTableBase):
    link: Optional[str] = None # Link will be generated by the backend

# Properties to receive via API for bulk creation
class ManagedTableBulkCreate(BaseModel):
    start_number: int = Field(..., example=1)
    end_number: int = Field(..., example=20)
    # branch_id will be derived from the authenticated user

# Properties to receive via API for bulk deletion
class ManagedTableBulkDelete(BaseModel):
    table_ids: List[int] = Field(..., example=[1, 3, 5])

# Properties to receive via API on update
class ManagedTableUpdate(BaseModel):
    table_number: Optional[int] = None # Usually not updated?
    override_main_qr_link: Optional[str] = None
    overridden_links: Optional[Dict[str, Any]] = None

# Properties shared by models stored in DB
class ManagedTableInDBBase(ManagedTableBase):
    id: int
    link: str # This is always present in the DB model

    class Config:
        orm_mode = True # Pydantic V1 style, use from_attributes=True for V2

# Properties to return to client
class ManagedTableRead(ManagedTableInDBBase):
    # Add related Branch info if needed later
    # branch: Optional[BranchSettingRead] = None
    pass

# Properties stored in DB
class ManagedTableInDB(ManagedTableInDBBase):
    pass 